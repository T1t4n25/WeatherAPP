# Weather Dashboard - Cursor Rules

## Stack
- **Backend**: Python 3.11+, FastAPI, Pydantic, httpx
- **Frontend**: Alpine.js (15KB), Tailwind CSS + Custom CSS (adaptive colors)
- **Icons**: Lucide Icons (weather icons via CDN)
- **Deployment**: Serverless-ready (Lambda, Vercel, Railway)
- **Design**: Adaptive Dynamic Palette (glanceability-first)

## Design Philosophy

**Adaptive colors = instant weather understanding**

| Condition | Colors | User Perception |
|-----------|---------|-----------------|
| Clear/Sunny | `#FFBA52 → #FF7A00` | Warm/Golden |
| Rainy/Overcast | `#748DA6 → #9CB4CC` | Cool/Grey |
| Cold/Snow | `#A0E7E5 → #B4F8C8` | Icy/Mint |
| Night | `#2C3E50 → #000000` | Dark |

**Logic**: Night → Cold (< 10°C) → Rainy → Sunny (default)

**OpenWeatherMap Keywords Coverage**:
- **Cold/Snow**: snow, sleet, ice, freezing, frost, blizzard
- **Rainy/Overcast**: rain, drizzle, shower, downpour, cloud, cloudy, overcast, grey, mist, fog, haze, smoke, dust, thunderstorm, storm, squall
- **Sunny**: clear, sunny, fair (default)

**Weather Icon Mapping (Lucide Icons)**:
| Condition | Icon | Description |
|-----------|------|-------------|
| Clear Day | `sun` | Bright sunshine |
| Clear Night | `moon` | Clear night sky |
| Cloudy Night | `cloud-moon` | Clouds at night |
| Starry Night | `moon-star` | Starry night |
| Thunderstorm | `cloud-lightning` | Storm with lightning |
| Snow | `snowflake` | Snowing |
| Sleet/Ice | `cloud-snow` | Mixed precipitation |
| Heavy Rain | `cloud-rain-wind` | Heavy rainfall |
| Light Rain | `cloud-rain` | Light rainfall |
| Fog/Mist | `cloud-fog` | Low visibility |
| Dust/Smoke | `wind` | Windy/dusty |
| Cloudy | `cloud` or `cloudy` | Cloud cover |

## Architecture

### Backend Structure
```
src/
├── domain/         # Business entities & exceptions
├── application/    # Services & use cases
├── infrastructure/ # FastAPI routes, external APIs
└── main.py
```

### Frontend Structure
```
static/
├── js/
│   ├── components/  # Alpine.js x-data objects
│   └── services/    # API calls
├── css/custom.css
└── index.html
```

## SOLID Principles

- **SRP**: One class = one responsibility
- **OCP**: Extend via interfaces, not modification
- **LSP**: All providers implement same interface
- **ISP**: Small, focused interfaces
- **DIP**: Depend on abstractions via FastAPI DI

## Code Standards

### Python
```python
from typing import Protocol
from dataclasses import dataclass
from functools import lru_cache

# Type hints mandatory
@dataclass
class WeatherData:
    temperature: float
    humidity: int
    description: str

# Protocols for interfaces
class WeatherProvider(Protocol):
    async def get_weather(self, lat: float, lon: float) -> WeatherData: ...

# Async I/O always
async def fetch_weather(): ...
```

**Rules**:
- Type hints everywhere
- Async for I/O
- Max 20 lines per function
- Google-style docstrings
- Use httpx.AsyncClient

### Alpine.js
```javascript
function weatherApp() {
  return {
    weather: null,
    loading: false,
    error: null,
    
    async init() {
      await this.detectLocation();
    },
    
    getWeatherClass() {
      if (!this.weather) return 'weather-sunny';
      
      const temp = this.weather.temperature;
      const desc = this.weather.description.toLowerCase();
      const hour = new Date().getHours();
      
      // Night (6pm - 6am)
      if (hour < 6 || hour >= 18) return 'weather-night';
      
      // Cold/Snow (below 10°C or snow conditions)
      const coldKeywords = ['snow', 'sleet', 'ice', 'freezing', 'frost', 'blizzard'];
      if (temp < 10 || coldKeywords.some(k => desc.includes(k))) {
        return 'weather-cold';
      }
      
      // Rainy/Overcast
      const rainyKeywords = [
        'rain', 'drizzle', 'shower', 'downpour', 'precipitation',
        'cloud', 'cloudy', 'overcast', 'grey', 'gray',
        'mist', 'fog', 'haze', 'smoke', 'dust',
        'thunderstorm', 'storm', 'squall'
      ];
      if (rainyKeywords.some(k => desc.includes(k))) {
        return 'weather-rainy';
      }
      
      // Default: Sunny/Clear
      return 'weather-sunny';
    },
    
    async fetchWeather(lat, lon) {
      this.loading = true;
      try {
        const res = await fetch(`/api/v1/weather?lat=${lat}&lon=${lon}`);
        this.weather = (await res.json()).data;
      } catch (e) {
        this.error = 'Failed to fetch weather';
      }
      this.loading = false;
    }
  };
}
```

**Rules**:
- Reactive state via x-data
- Use async/await
- Max 100 lines per component
- Dynamic class binding with :class
- Weather keywords mapping:
  - **Cold**: snow, sleet, ice, freezing, frost, blizzard
  - **Rainy**: rain, drizzle, shower, cloud, overcast, mist, fog, haze, smoke, dust, thunderstorm, storm, squall
  - **Sunny**: clear, sunny, fair (default fallback)

### CSS (Adaptive Dynamic Palette)
```css
/* Weather-based color system for glanceability */
:root {
  /* Clear/Sunny */
  --sunny-from: #FFBA52;
  --sunny-to: #FF7A00;
  
  /* Rainy/Overcast */
  --rainy-from: #748DA6;
  --rainy-to: #9CB4CC;
  
  /* Cold/Snow */
  --cold-from: #A0E7E5;
  --cold-to: #B4F8C8;
  
  /* Night */
  --night-from: #2C3E50;
  --night-to: #000000;
}

.weather-sunny { background: linear-gradient(to br, var(--sunny-from), var(--sunny-to)); }
.weather-rainy { background: linear-gradient(to br, var(--rainy-from), var(--rainy-to)); }
.weather-cold { background: linear-gradient(to br, var(--cold-from), var(--cold-to)); }
.weather-night { background: linear-gradient(to br, var(--night-from), var(--night-to)); }
```

```html
<div :class="getWeatherClass()" class="min-h-screen transition-colors duration-700">
  <div class="max-w-md mx-auto p-6">
    <div class="bg-white/90 backdrop-blur-sm rounded-2xl shadow-xl p-8">
      <!-- Content -->
    </div>
  </div>
</div>
```

**Rules**: 
- Dynamic background based on weather conditions & temperature
- Use CSS variables for weather colors
- Smooth transitions (700ms) between states
- Semi-transparent cards with backdrop blur
- Text color adapts to background (white on dark, dark on light)

## Error Handling

### Backend
```python
class WeatherAppException(Exception): pass
class LocationNotFoundError(WeatherAppException): pass
class WeatherAPIError(WeatherAppException): pass

@app.exception_handler(LocationNotFoundError)
async def handler(request, exc):
    return JSONResponse(
        status_code=404,
        content={"error": "location_not_found", "message": str(exc)}
    )
```

### Frontend
```javascript
async fetchWeather(lat, lon) {
  try {
    const res = await fetch(`/api/v1/weather?lat=${lat}&lon=${lon}`);
    if (!res.ok) {
      const err = await res.json();
      this.error = err.message;
      return;
    }
    this.weather = await res.json();
  } catch (e) {
    this.error = 'Network error';
  }
}
```

## API Design

```python
# GET /api/v1/weather/current?lat={lat}&lon={lon}
{
  "data": {
    "temperature": 22.5,
    "humidity": 65,
    "wind_speed": 3.2,
    "description": "Partly cloudy",
    "city": "London"
  },
  "timestamp": "2024-01-20T10:30:00Z"
}

# POST /api/v1/weather/by-city
# Body: {"city": "London"}
```

**Rules**: Version APIs (/api/v1/), validate with Pydantic, consistent response format

## Configuration (.env)

```bash
# .env (NEVER commit)
OPENWEATHER_API_KEY=your_key
ENVIRONMENT=development
CACHE_TTL=300
```

```python
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    openweather_api_key: str
    environment: str = "development"
    cache_ttl: int = 300
    
    class Config:
        env_file = ".env"

@lru_cache()
def get_settings() -> Settings:
    return Settings()
```

## Serverless Requirements

✅ All secrets in environment variables
✅ Use @lru_cache() for singletons
✅ Stateless handlers
✅ No file system writes
✅ Connection pooling with cleanup
✅ Read from env, not files

```python
# Good
@lru_cache()
def get_settings():
    return Settings()  # Reads from env

# Bad
def load_config():
    with open('config.json'): ...  # Fails in serverless
```

## Testing (Minimal)

```python
from fastapi.testclient import TestClient

def test_weather_endpoint():
    response = client.get("/api/v1/weather?lat=51.5074&lon=-0.1278")
    assert response.status_code == 200
    assert "data" in response.json()

def test_invalid_coords():
    response = client.get("/api/v1/weather?lat=invalid&lon=invalid")
    assert response.status_code == 422
```

**Focus**: Critical endpoints only, Pydantic validates automatically

**Frontend**: Manual testing checklist (location, errors, responsive, browsers)

## Performance

- Async I/O everywhere
- Simple dict caching (5min TTL)
- httpx connection pooling
- Alpine.js already lightweight
- Debounce city search (300ms)

## Security

✅ API keys in .env only
✅ Pydantic validates inputs
✅ Sanitize error messages
✅ CORS configured
❌ No auth/login (not needed)

## Git Commits

Format: `type(scope): description`

Types: feat, fix, refactor, test, docs, style, chore

Example: `feat(backend): add weather service with OpenWeatherMap`

## Checklist

### Before Commit
- [ ] Manual browser test
- [ ] No console errors
- [ ] Test error scenarios
- [ ] .env not committed
- [ ] Meaningful commit message

### Before Deploy
- [ ] Chrome & Firefox tested
- [ ] Mobile responsive
- [ ] Env vars documented

## Patterns

### FastAPI DI
```python
from fastapi import Depends

async def get_service() -> WeatherService:
    settings = get_settings()
    return WeatherService(httpx.AsyncClient(), settings)

@app.get("/weather")
async def get_weather(service: WeatherService = Depends(get_service)):
    return await service.fetch(lat, lon)
```

### Alpine Components
```html
<!-- Include Lucide Icons -->
<script src="https://unpkg.com/lucide@latest"></script>

<div x-data="weatherApp()" :class="getWeatherClass()" class="min-h-screen transition-colors duration-700">
  <div class="max-w-md mx-auto p-6">
    <div class="bg-white/90 backdrop-blur-sm rounded-2xl shadow-xl p-8">
      <div x-show="loading">Loading...</div>
      <div x-show="error" x-text="error" class="text-red-600"></div>
      <div x-show="weather">
        <!-- Weather Icon -->
        <div class="flex justify-center mb-4">
          <i :data-lucide="getWeatherIcon()" class="w-24 h-24"></i>
        </div>
        
        <h1 x-text="weather?.city" class="text-3xl font-bold text-center"></h1>
        <p x-text="`${weather?.temperature}°C`" class="text-6xl text-center"></p>
        <p x-text="weather?.description" class="text-center capitalize"></p>
      </div>
    </div>
  </div>
</div>

<script>
  // Initialize Lucide icons after Alpine renders
  document.addEventListener('alpine:initialized', () => {
    lucide.createIcons();
  });
  
  // Re-initialize when weather updates
  document.addEventListener('alpine:update', () => {
    lucide.createIcons();
  });
</script>
```

**Note**: 
- Dynamic background changes based on weather
- Dynamic weather icons using Lucide
- Icons update automatically with weather changes
- Use `:data-lucide` binding for reactive icon rendering

## Anti-Patterns

❌ Over-engineering (keep it simple)
❌ Magic numbers (use config)
❌ Global mutable state
❌ Secrets in code
❌ Stateful serverless
❌ Complex builds

## Commands

```bash
# Dev
uvicorn src.main:app --reload --port 8000

# Install
pip install fastapi uvicorn httpx pydantic-settings python-dotenv

# Setup
cp .env.example .env

# Deploy
vercel deploy  # or railway up, gcloud run deploy
```

## Remember

- Simple > Complex
- Serverless-first (stateless, env vars)
- Alpine.js for reactive UI
- Pydantic validates automatically
- .env for all secrets
- Make it work → make it right → make it fast